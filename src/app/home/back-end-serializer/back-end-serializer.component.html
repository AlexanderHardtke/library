<section>

    <h1>Django Serializers</h1><button routerLink="" class="backBtn">Back</button>

    <div>
        <h3>Tipp1</h3>
        <h3>nested serializers</h3>
        <p>selbst gebaute serializer in many to many field einbauen<br>
            markets = MarketSerializer(many=True, read_only=True)<br>
            nested werden auch vorher mit.pop entfernt und im nachgang mit .set wieder hinzugefügt
        </p>
    </div>

    <div>
        <h3>Tipp2</h3>
        <h3>Model Serializer</h3>
        <p>es wird automatisch ein set fields generiert basierend auf dem Model<br>
            automatische validatoren und includes update() und create()<br>
            Extrem zeitsparend, Nachteil: geht auch nicht ohne Model und für komplexe Lösungen
        </p>
    </div>

    <div>
        <h3>Tipp3</h3>
        <h3>Hyperlinkrelatedfield</h3>
        <p>einen view_name='seller_single' geben<br>
            AssertionError: Add `context='request': request`<br>
            hier den context hinter die Felder in der View dem serlializer übergeben
        </p>
    </div>

    <div>
        <h3>Tipp4</h3>
        <h3>inheritance</h3>
        <p>Serializers können Eigenschaften vererben und erweitert werden<br>
            Wenn z.B in der Single View mehr Infos sein sollen als in der multiple view
        </p>
    </div>

    <div>
        <h3>Tipp5</h3>
        <h3>Base und List serializer</h3>
        <p>BaseSerilaizer ist für sehr basic dinge da mir Varianten in der Doku<br>
            many=True für den List Serializer<br>
            Edge-Cases
        </p>
    </div>

    <div>
        <h3>Tipp6</h3>
        <h3>APIViews einfacher</h3>
        <p>z.B. Mixins, Doku importieren und für jedes view Klasse machen<br>
            class SellerView(mixins.ListModelMixin,
            mixins.CreateModelMixin,
            generics.GenericAPIView):

            queryset = Seller.objects.all()
            serializer_class = SellersSerializer


            def get(self, request, *args, **kwargs):
            return self.list(request, *args, **kwargs)

            def post(self, request, *args, **kwargs):
            return self.create(request, *args, **kwargs)
        </p>
    </div>

    <div>
        <h3>Tipp7</h3>
        <h3>Beispiel für modifizierte ListView</h3>
        <p>class SellerOfMarketList(generics.ListCreateAPIView):
            serializer_class = SellersSerializer

            def get_queryset(self):
            pk = self.kwargs.get('pk')
            market = Market.objects.get(pk=pk)
            return market.sellers.all()
        </p>
    </div>

    <div>
        <h3>Tipp8</h3>
        <h3>Django 5.2</h3>
        <p>models.CompositePrimaryKey("version", "name")<br>
            Hiermit kann ich einen int und einen str als pk weiter geben, z.B. BusinessUser und die id<br>
            Kann zum sortieren einfacher sein, eine View statt 2
        </p>
    </div>


    <div>
        <h3>Tipp 9</h3>
        <h3>Filtern mit queryset</h3>
        <p>am ende der URL ?content=Django&author=bob<br>
            mit Postman in die Params den key z.B. content und den Value Django
        </p>
    </div>


    <div>
        <h3>Tipp 10</h3>
        <h3>filter search</h3>
        <p>implementieren um auch nur Bruchstücke oder keywords zu suchen<br>
            prefixes vor dem search um zu spezifizieren
        </p>
    </div>


    <div>
        <h3>Tipp 11</h3>
        <h3>ordering -> sortierung</h3>
        <p>wird genau so implementiert wie filter search<br>
            kann mit - umgedreht werden oder mit anderen values z.B. in Postman keyword ordering geändert werden
        </p>
    </div>


    <div>
        <h3>Tipp 12</h3>
        <h3>pagination</h3>
        <p>implementieren um größere Daten Mengen in mehreren Seiten abzubilden<br>
            Postmann = key page und value mit der nummer der Seite<br>
            page-site lässt sich auch im backend ändern<br>
            Alternativ auch als default setzen möglich in der setting.py
        </p>
    </div>


    <div>
        <h3>Tipp 13</h3>
        <h3>pagination limit offset</h3>
        <p>Andere Methode aber mit einem Limit und einem offset<br>
            User kann hier einfacher sagen ab wann und wie viel anzeigen
        </p>
    </div>

</section>